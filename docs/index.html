<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Par for the Course — Tournament Groups + Scoring</title>

  <style>
    :root{
      --bg:#0b1020;
      --text:#eaf0ff;
      --muted:#a8b3d6;
      --line:rgba(255,255,255,.10);
      --accent:#4cd3ff;
      --good:#3ee37b;
      --warn:#ffcf5a;
      --bad:#ff5f6d;
      --shadow: 0 12px 28px rgba(0,0,0,.35);
      --radius:16px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background: radial-gradient(1200px 800px at 15% 10%, rgba(76,211,255,.12), transparent 60%),
                  radial-gradient(1000px 700px at 90% 0%, rgba(62,227,123,.10), transparent 55%),
                  radial-gradient(900px 700px at 80% 90%, rgba(255,95,109,.10), transparent 55%),
                  var(--bg);
    }
    header{
      position:sticky; top:0; z-index:50;
      background: linear-gradient(to bottom, rgba(11,16,32,.95), rgba(11,16,32,.70));
      backdrop-filter: blur(10px);
      border-bottom:1px solid var(--line);
    }
    .wrap{
      max-width: 1200px;
      margin: 0 auto;
      padding: 14px 18px;
    }
    .topbar{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
    }
    .brand{ display:flex; flex-direction:column; gap:2px; }
    .brand h1{ margin:0; font-size:18px; letter-spacing:.2px; }
    .brand .sub{ color:var(--muted); font-size:12px; }

    .actions{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    button{
      appearance:none; border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      color:var(--text);
      padding:10px 12px;
      border-radius: 12px;
      cursor:pointer;
      box-shadow: 0 6px 18px rgba(0,0,0,.18);
      transition: transform .06s ease, border-color .2s ease, background .2s ease;
      font-weight:600;
    }
    button:hover{ border-color: rgba(76,211,255,.35); }
    button:active{ transform: translateY(1px); }
    button.primary{
      border-color: rgba(76,211,255,.45);
      background: linear-gradient(180deg, rgba(76,211,255,.18), rgba(76,211,255,.06));
    }
    button.danger{
      border-color: rgba(255,95,109,.45);
      background: linear-gradient(180deg, rgba(255,95,109,.18), rgba(255,95,109,.06));
    }
    button.ghost{ background: transparent; box-shadow:none; }
    button.small{ padding:8px 10px; border-radius:10px; font-size:12px; }

    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.03);
      border-radius:999px;
      color:var(--muted);
      font-size:12px;
    }

    main{ padding: 18px 0 40px; }
    .grid{
      display:grid;
      grid-template-columns: 420px 1fr;
      gap: 16px;
      align-items:start;
    }
    .card{
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.045), rgba(255,255,255,.02));
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card .hd{
      padding:14px 14px 10px;
      border-bottom:1px solid var(--line);
      display:flex; align-items:flex-start; justify-content:space-between; gap:10px;
    }
    .card .hd h2{ margin:0; font-size:14px; letter-spacing:.2px; }
    .card .hd p{ margin:4px 0 0; color:var(--muted); font-size:12px; line-height:1.35; }
    .card .bd{ padding:14px; }

    textarea{
      width:100%;
      min-height: 220px;
      resize: vertical;
      border-radius: 14px;
      padding: 12px 12px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.25);
      color: var(--text);
      outline:none;
      font-family: var(--mono);
      font-size: 13px;
      line-height: 1.45;
    }
    textarea:focus{ border-color: rgba(76,211,255,.5); }

    .row{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
    .hint{ font-size:12px; color:var(--muted); line-height:1.4; margin-top:8px; }

    .tabs{ display:flex; gap:10px; padding: 10px 14px 0; }
    .tab{
      padding: 10px 12px;
      border-radius: 12px 12px 0 0;
      border: 1px solid var(--line);
      border-bottom: none;
      background: rgba(255,255,255,.03);
      color: var(--muted);
      cursor:pointer;
      user-select:none;
      font-weight:700;
      font-size: 12px;
    }
    .tab.active{
      background: linear-gradient(180deg, rgba(76,211,255,.14), rgba(255,255,255,.02));
      color: var(--text);
      border-color: rgba(76,211,255,.35);
    }

    /* Progress board */
    .progressBoard{
      margin-bottom: 14px;
      border:1px solid var(--line);
      border-radius: var(--radius);
      background: linear-gradient(180deg, rgba(0,0,0,.18), rgba(255,255,255,.02));
      box-shadow: 0 10px 22px rgba(0,0,0,.20);
      overflow:hidden;
    }
    .progressBoard .ph{
      padding: 12px 12px 10px;
      border-bottom:1px solid rgba(255,255,255,.08);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .progressBoard .ph .t{ font-weight:900; font-size:13px; }
    .progressBoard .ph .s{ color:var(--muted); font-size:12px; }
    .progressBoard .pb{ padding:0; }
    table{ width:100%; border-collapse: collapse; font-size: 13px; }
    th, td{ padding: 10px 10px; border-bottom:1px solid rgba(255,255,255,.06); text-align:left; }
    th{ color: var(--muted); font-size: 12px; font-weight: 800; letter-spacing:.2px; }
    td.r{ text-align:right; font-family: var(--mono); font-weight:800; }

    /* Group blocks */
    .groupGrid{ display:grid; grid-template-columns: 1fr; gap: 14px; }
    .group{
      border:1px solid var(--line);
      border-radius: var(--radius);
      background: linear-gradient(180deg, rgba(0,0,0,.18), rgba(255,255,255,.02));
      overflow:hidden;
      box-shadow: 0 10px 22px rgba(0,0,0,.25);
      position: relative;
    }
    .group.flash{
      outline: 2px solid rgba(76,211,255,.55);
      box-shadow: 0 0 0 6px rgba(76,211,255,.10), 0 10px 22px rgba(0,0,0,.25);
    }
    .groupHead{
      padding: 12px 12px 10px;
      border-bottom:1px solid var(--line);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .gmeta{ display:flex; flex-direction:column; gap:2px; }
    .gmeta .title{ font-weight: 900; font-size: 13px; letter-spacing:.2px; }
    .gmeta .sub{ font-size: 12px; color: var(--muted); }
    .inline{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }

    .badge{
      display:inline-flex; align-items:center;
      padding: 4px 8px;
      border-radius:999px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.03);
      color: var(--muted);
      font-size: 11px;
      font-weight:800;
      margin-left: 8px;
    }

    /* Group hole control */
    .holeCtl{
      display:flex; align-items:center; gap:8px; flex-wrap:wrap;
      padding: 10px 12px;
      border-bottom:1px solid rgba(255,255,255,.06);
      background: rgba(255,255,255,.02);
    }
    .holeBig{
      font-weight: 900;
      font-family: var(--mono);
      letter-spacing:.2px;
    }
    select{
      border-radius: 12px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.22);
      color: var(--text);
      padding: 8px 10px;
      outline:none;
      font-weight: 800;
    }
    select:focus{ border-color: rgba(76,211,255,.5); }

    .entryRow{
      display:grid;
      grid-template-columns: 220px 1fr 90px;
      gap: 10px;
      padding: 10px 12px;
      border-top:1px solid rgba(255,255,255,.06);
      align-items:center;
    }
    .entryRow:first-child{ border-top:none; }
    .pname{
      font-weight: 800;
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .scoreInput{
      width:100%;
      padding: 10px 10px;
      border-radius: 12px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.22);
      color: var(--text);
      outline:none;
      font-family: var(--mono);
      font-size: 13px;
    }
    .scoreInput:focus{ border-color: rgba(76,211,255,.5); }
    .ptotal{ text-align:right; font-family: var(--mono); font-weight: 900; }

    .note{ margin-top: 10px; color: var(--muted); font-size: 12px; line-height: 1.45; }

    .footerMini{
      margin-top: 10px;
      display:flex;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
      color: var(--muted);
      font-size: 12px;
    }

    /* Modal */
    .modalBack{
      position: fixed;
      inset:0;
      background: rgba(0,0,0,.55);
      display:none;
      align-items:center;
      justify-content:center;
      z-index: 1000;
      padding: 18px;
    }
    .modal{
      width: min(820px, 100%);
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(16,26,51,.96), rgba(8,12,24,.96));
      border-radius: 18px;
      box-shadow: 0 18px 60px rgba(0,0,0,.55);
      overflow:hidden;
    }
    .modal .mh{
      padding: 14px 14px 10px;
      border-bottom:1px solid var(--line);
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
    }
    .modal .mh h3{ margin:0; font-size: 14px; }
    .modal .mh p{ margin:4px 0 0; color: var(--muted); font-size: 12px; line-height: 1.35; }
    .modal .mb{ padding: 14px; }
    .sdRow{
      display:grid;
      grid-template-columns: 1fr 160px;
      gap: 10px;
      align-items:center;
      padding: 10px 0;
      border-bottom:1px solid rgba(255,255,255,.06);
    }
    .sdRow:last-child{ border-bottom:none; }

    .bkRow{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:10px;
      align-items:center;
      padding: 10px 0;
      border-bottom:1px solid rgba(255,255,255,.06);
    }
    .bkRow:last-child{ border-bottom:none; }
    .bkMeta{ display:flex; flex-direction:column; gap:2px; }
    .bkMeta .t{ font-weight:900; font-size: 13px; }
    .bkMeta .s{ color:var(--muted); font-size: 12px; }
    .bkMeta .k{ display:flex; gap:8px; flex-wrap:wrap; margin-top:4px; }
    .bkChip{
      display:inline-flex; align-items:center; gap:6px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
      color: var(--muted);
      font-size: 11px;
      font-weight: 800;
    }

    @media (max-width: 1080px){
      .grid{ grid-template-columns: 1fr; }
      .entryRow{ grid-template-columns: 1fr 1fr 90px; }
    }
  </style>
</head>

<body>
<header>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">
        <h1>Par for the Course — Tournament Scoring</h1>
        <div class="sub">18 holes • Lowest strokes wins • Random groups • Per-group holes • Autosave + Manual Backups</div>
      </div>
      <div class="actions">
        <span class="pill" id="statusPill">Ready</span>
        <button class="primary small" id="btnBackupNow">Backup Now</button>
        <button class="ghost small" id="btnRestoreBackup">Restore…</button>
        <button class="ghost small" id="btnDownloadBackup">Download Backup</button>
        <button class="ghost small" id="btnImport">Import Backup</button>
        <button class="danger small" id="btnReset">Reset</button>
      </div>
    </div>
  </div>
</header>

<main class="wrap">
  <div class="grid">
    <!-- Left: Setup -->
    <section class="card">
      <div class="hd">
        <div>
          <h2>Roster + Grouping</h2>
          <p>Enter up to 24 players (one per line). Format: “FirstName L” (e.g., “Ace R”).</p>
        </div>
        <div class="inline">
          <span class="pill" id="playerCountPill">0 players</span>
        </div>
      </div>
      <div class="bd">
        <textarea id="namesInput" placeholder="Example:
Ace R
Sammy G
Teddy R
..."></textarea>

        <div class="row">
          <button class="primary" id="btnBuild">Shuffle + Create Groups</button>
          <button id="btnReshuffle">Re-shuffle</button>
          <button class="ghost" id="btnClearNames">Clear Names</button>
        </div>

        <div class="hint">
          Grouping rule: <b>16–24 → groups of 4</b>. <b>&lt;16 → groups of 2</b>.
          If it doesn’t divide cleanly, the app creates <b>one 3-person group</b> (no BYEs).
        </div>

        <div class="note">
          <b>Key nuance supported:</b> groups can be on different holes at the same time.
          Each group card has its own <b>Current Hole</b> control.
        </div>

        <div class="note">
          <b>Data safety:</b> Autosave protects refresh/crash. Use <b>Backup Now</b> for restore points.
          Use <b>Download Backup</b> if you want a copy off-device.
        </div>
      </div>
    </section>

    <!-- Right: Tournament -->
    <section>
      <div class="tabs">
        <div class="tab active" data-tab="scoring">Scoring</div>
        <div class="tab" data-tab="leaderboard">Leaderboard</div>
      </div>

      <div class="card" style="border-top-left-radius:0;">
        <div class="bd">

          <!-- Progress board -->
          <div class="progressBoard" id="progressBoard" style="display:none;">
            <div class="ph">
              <div>
                <div class="t">Progress Board</div>
                <div class="s">Quick at-a-glance: where each group is, and data completeness.</div>
              </div>
              <div class="pill">Autosave: <span id="saveState">off</span> • Backups: <span id="backupCount">0</span></div>
            </div>
            <div class="pb">
              <table>
                <thead>
                  <tr>
                    <th style="width:90px;">Group</th>
                    <th style="width:150px;">Current Hole</th>
                    <th class="r" style="width:170px;">Max holes entered</th>
                    <th class="r" style="width:170px;">Players complete</th>
                    <th>Players</th>
                  </tr>
                </thead>
                <tbody id="pbBody"></tbody>
              </table>
            </div>
          </div>

          <!-- Scoring view -->
          <div id="viewScoring">
            <div class="groupGrid" id="groups"></div>
            <div class="note" id="groupingNote" style="display:none;"></div>
          </div>

          <!-- Leaderboard view -->
          <div id="viewLeaderboard" style="display:none;">
            <div class="inline" style="justify-content:space-between; margin-bottom:10px;">
              <div class="pill" id="lbMeta">No data yet</div>
              <div class="inline">
                <button class="small" id="btnSortTotal">Sort by Total</button>
                <button class="small" id="btnSortProgress">Sort by Holes Played</button>
                <button class="small" id="btnShowTies">Resolve Ties (Sudden Death)</button>
              </div>
            </div>

            <div class="card" style="box-shadow:none; background: rgba(0,0,0,.12);">
              <div class="bd" style="padding:0;">
                <table>
                  <thead>
                    <tr>
                      <th style="width:60px;">Rank</th>
                      <th>Player</th>
                      <th style="width:110px;">Group</th>
                      <th class="r" style="width:120px;">Holes</th>
                      <th class="r" style="width:140px;">Total</th>
                      <th style="width:160px;">Tie Status</th>
                    </tr>
                  </thead>
                  <tbody id="lbBody"></tbody>
                </table>
              </div>
            </div>

            <div class="note">
              <b>Sudden death tiebreak:</b> If totals tie, enter one extra hole score for tied players.
              Lowest sudden-death score ranks above others with the same total.
            </div>
          </div>

          <div class="footerMini">
            <div>Tip: set each group’s hole manually at the start, then just ride the ◀ ▶ buttons as they advance.</div>
            <div style="text-align:right;">Local-only app. Use Download Backup for an off-device copy.</div>
          </div>

        </div>
      </div>
    </section>
  </div>
</main>

<!-- Modal (reused for: Sudden Death, Scorecard, Backups) -->
<div class="modalBack" id="modalBack">
  <div class="modal">
    <div class="mh">
      <div>
        <h3 id="modalTitle">Modal</h3>
        <p id="modalDesc">Description</p>
      </div>
      <button class="ghost small" id="btnCloseModal">Close</button>
    </div>
    <div class="mb">
      <div id="modalBody"></div>
      <div class="row" style="justify-content:flex-end; margin-top:12px;">
        <button class="primary" id="btnModalPrimary">Done</button>
      </div>
      <div class="note" id="modalNote" style="display:none;"></div>
    </div>
  </div>
</div>

<script>
(() => {
  const STORAGE_KEY = "pftc_tourney_v2";
  const BACKUP_KEY  = "pftc_tourney_v2_backups";
  const MAX_BACKUPS = 20;

  const state = {
    namesRaw: "",
    players: [], // [{id, name, groupIndex}]
    groups: [],  // [[playerId,...], ...]
    scores: {},  // scores[playerId][holeIndex]=number|null
    suddenDeath: {}, // suddenDeath[playerId]=number|null
    leaderboardSort: "total", // "total" | "progress"
    _groupingNote: "",
    groupHoles: {} // groupHoles[groupIndex]=0..17 (manual per-group)
  };

  const $ = (sel) => document.querySelector(sel);
  const $$ = (sel) => Array.from(document.querySelectorAll(sel));

  const els = {
    namesInput: $("#namesInput"),
    playerCountPill: $("#playerCountPill"),
    statusPill: $("#statusPill"),

    btnBuild: $("#btnBuild"),
    btnReshuffle: $("#btnReshuffle"),
    btnClearNames: $("#btnClearNames"),

    progressBoard: $("#progressBoard"),
    pbBody: $("#pbBody"),
    groupingNote: $("#groupingNote"),

    groups: $("#groups"),

    tabs: $$(".tab"),
    viewScoring: $("#viewScoring"),
    viewLeaderboard: $("#viewLeaderboard"),
    lbBody: $("#lbBody"),
    lbMeta: $("#lbMeta"),
    btnSortTotal: $("#btnSortTotal"),
    btnSortProgress: $("#btnSortProgress"),
    btnShowTies: $("#btnShowTies"),

    // Modal
    modalBack: $("#modalBack"),
    btnCloseModal: $("#btnCloseModal"),
    modalTitle: $("#modalTitle"),
    modalDesc: $("#modalDesc"),
    modalBody: $("#modalBody"),
    btnModalPrimary: $("#btnModalPrimary"),
    modalNote: $("#modalNote"),

    // Safety
    saveState: $("#saveState"),
    backupCount: $("#backupCount"),
    btnBackupNow: $("#btnBackupNow"),
    btnRestoreBackup: $("#btnRestoreBackup"),
    btnDownloadBackup: $("#btnDownloadBackup"),
    btnImport: $("#btnImport"),
    btnReset: $("#btnReset")
  };

  // ---------- utilities ----------
  function setStatus(text, tone="ready"){
    els.statusPill.textContent = text;
    const map = {
      ready: "rgba(255,255,255,.03)",
      saving: "rgba(255,207,90,.10)",
      ok: "rgba(62,227,123,.10)",
      warn: "rgba(255,207,90,.10)",
      bad: "rgba(255,95,109,.10)"
    };
    els.statusPill.style.background = map[tone] || map.ready;
    els.statusPill.style.borderColor = tone==="ok" ? "rgba(62,227,123,.35)" :
                                      tone==="warn" ? "rgba(255,207,90,.35)" :
                                      tone==="bad" ? "rgba(255,95,109,.35)" :
                                      "rgba(255,255,255,.10)";
    els.statusPill.style.color = "var(--muted)";
  }

  function clampInt(v, min, max){
    v = Number(v);
    if(!Number.isFinite(v)) return min;
    return Math.max(min, Math.min(max, Math.floor(v)));
  }

  function escapeHtml(str){
    return String(str)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  function nowStamp(){
    const d = new Date();
    const pad = (n) => String(n).padStart(2,"0");
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
  }

  function deepClone(obj){
    return JSON.parse(JSON.stringify(obj));
  }

  function parseNames(raw){
    return raw
      .split("\n")
      .map(s => s.trim())
      .filter(Boolean)
      .slice(0, 24);
  }

  // ---------- autosave ----------
  function save(){
    setStatus("Saving…", "saving");
    try{
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      if (els.saveState) els.saveState.textContent = "on";
      setStatus("Saved", "ok");
      setTimeout(() => setStatus("Ready", "ready"), 650);
    }catch(e){
      if (els.saveState) els.saveState.textContent = "off";
      setStatus("Save failed", "bad");
      console.error(e);
    }
    renderBackupCount();
  }

  function load(){
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      if(!raw) return false;
      const loaded = JSON.parse(raw);
      Object.assign(state, loaded);

      state.players ||= [];
      state.groups ||= [];
      state.scores ||= {};
      state.suddenDeath ||= {};
      state.leaderboardSort ||= "total";
      state._groupingNote ||= "";
      state.groupHoles ||= {};

      return true;
    }catch(e){
      console.error(e);
      return false;
    }
  }

  // ---------- backups ----------
  function getBackups(){
    try{
      const raw = localStorage.getItem(BACKUP_KEY);
      const arr = raw ? JSON.parse(raw) : [];
      return Array.isArray(arr) ? arr : [];
    }catch{
      return [];
    }
  }
  function setBackups(arr){
    localStorage.setItem(BACKUP_KEY, JSON.stringify(arr));
  }
  function renderBackupCount(){
    const bks = getBackups();
    if (els.backupCount) els.backupCount.textContent = String(bks.length);
  }

  function summarizeStateForBackup(st){
    const players = st.players?.length || 0;
    const groups = st.groups?.length || 0;
    let holesMax = 0;
    let completed = 0;
    for(const p of st.players || []){
      const arr = st.scores?.[p.id] || [];
      const played = arr.reduce((c,v)=> c + (Number.isFinite(v) ? 1 : 0), 0);
      holesMax = Math.max(holesMax, played);
      if(played === 18) completed++;
    }
    return { players, groups, holesMax, completed };
  }

  function backupNow(){
    const bks = getBackups();
    const snapshot = {
      id: `bk_${Date.now()}_${Math.random().toString(16).slice(2,8)}`,
      createdAt: nowStamp(),
      meta: summarizeStateForBackup(state),
      payload: deepClone(state)
    };
    bks.unshift(snapshot);
    if(bks.length > MAX_BACKUPS) bks.length = MAX_BACKUPS;
    setBackups(bks);
    renderBackupCount();
    setStatus("Backup saved", "ok");
  }

  function openBackupsModal(){
    const bks = getBackups();
    els.modalTitle.textContent = "Restore from a backup";
    els.modalDesc.textContent = "Backups are local snapshots saved by clicking “Backup Now”. Choose one to restore.";
    els.modalBody.innerHTML = "";
    els.modalNote.style.display = "block";
    els.modalNote.textContent = "If you want true catastrophe-proofing (device dies), use “Download Backup” and store the file off-device.";

    if(bks.length === 0){
      els.modalBody.innerHTML = `<div class="note">No backups yet. Click <b>Backup Now</b> during the tournament to create restore points.</div>`;
      els.btnModalPrimary.textContent = "Done";
      els.btnModalPrimary.onclick = () => closeModal();
      openModal();
      return;
    }

    const list = document.createElement("div");
    for(const bk of bks){
      const meta = bk.meta || {};
      const row = document.createElement("div");
      row.className = "bkRow";
      row.innerHTML = `
        <div class="bkMeta">
          <div class="t">${escapeHtml(bk.createdAt || "Unknown time")}</div>
          <div class="s">Snapshot of your tournament state</div>
          <div class="k">
            <span class="bkChip">Players: ${meta.players ?? "—"}</span>
            <span class="bkChip">Groups: ${meta.groups ?? "—"}</span>
            <span class="bkChip">Max holes entered: ${meta.holesMax ?? "—"}/18</span>
            <span class="bkChip">Completed: ${meta.completed ?? "—"}</span>
          </div>
        </div>
        <div class="inline">
          <button class="primary small" data-restore="${bk.id}">Restore</button>
        </div>
      `;
      row.querySelector("button[data-restore]").addEventListener("click", () => restoreBackupById(bk.id));
      list.appendChild(row);
    }

    els.modalBody.appendChild(list);
    els.btnModalPrimary.textContent = "Close";
    els.btnModalPrimary.onclick = () => closeModal();
    openModal();
  }

  function restoreBackupById(id){
    const bks = getBackups();
    const bk = bks.find(x => x.id === id);
    if(!bk) return;

    if(!confirm("Restore this backup? This overwrites your current tournament state.")) return;

    const restored = bk.payload;
    Object.assign(state, restored);

    state.players ||= [];
    state.groups ||= [];
    state.scores ||= {};
    state.suddenDeath ||= {};
    state.leaderboardSort ||= "total";
    state._groupingNote ||= "";
    state.groupHoles ||= {};

    els.namesInput.value = state.namesRaw || state.players.map(p=>p.name).join("\n");
    save();
    renderAll();
    closeModal();
    setStatus("Backup restored", "ok");
  }

  // ---------- shuffle/group logic ----------
  function mulberry32(seed){
    return function(){
      let t = seed += 0x6D2B79F5;
      t = Math.imul(t ^ (t >>> 15), t | 1);
      t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }
  function shuffleArray(arr, seed){
    const rand = mulberry32(seed);
    const a = arr.slice();
    for(let i = a.length - 1; i > 0; i--){
      const j = Math.floor(rand() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  function makeGroups(shuffledIds, baseSize){
    const n = shuffledIds.length;
    const groups = [];
    let note = "";

    if(n === 0) return {groups, note};

    if(baseSize === 2){
      let i = 0;
      while(i < n){
        const remaining = n - i;
        if(remaining === 3){
          groups.push(shuffledIds.slice(i, i+3));
          i += 3;
          note = "Note: odd count detected → created one 3-person group (no BYEs).";
        }else{
          groups.push(shuffledIds.slice(i, i+2));
          i += 2;
        }
      }
      return {groups, note};
    }

    const rem = n % 4;
    if(rem === 0){
      for(let i=0;i<n;i+=4) groups.push(shuffledIds.slice(i,i+4));
      return {groups, note};
    }
    if(rem === 3){
      const cutoff = n - 3;
      for(let i=0;i<cutoff;i+=4) groups.push(shuffledIds.slice(i,i+4));
      groups.push(shuffledIds.slice(cutoff));
      note = "Note: remainder detected → created one 3-person group (no BYEs).";
      return {groups, note};
    }
    if(rem === 2){
      const cutoff = n - 2;
      for(let i=0;i<cutoff;i+=4) groups.push(shuffledIds.slice(i,i+4));
      groups.push(shuffledIds.slice(cutoff));
      note = "Note: remainder detected → created one 2-person group (no BYEs).";
      return {groups, note};
    }

    // rem === 1 → split last 5 into 3 + 2
    if(n < 5){
      groups.push(shuffledIds.slice());
      note = "Note: small field → created one group (no BYEs).";
      return {groups, note};
    }
    const cutoff = n - 5;
    for(let i=0;i<cutoff;i+=4) groups.push(shuffledIds.slice(i,i+4));
    const last5 = shuffledIds.slice(cutoff);
    groups.push(last5.slice(0,3));
    groups.push(last5.slice(3,5));
    note = "Note: remainder 1 detected → created one 3-person group + one 2-person group (no BYEs).";
    return {groups, note};
  }

  function buildTournamentFromNames(names){
    state.players = names.map((name, idx) => ({
      id: `p_${idx}_${name.replace(/\s+/g,"_").slice(0,18)}`,
      name,
      groupIndex: -1
    }));

    state.scores = {};
    state.suddenDeath = {};
    for(const p of state.players){
      state.scores[p.id] = Array(18).fill(null);
      state.suddenDeath[p.id] = null;
    }

    const seed = Date.now() >>> 0;
    const shuffled = shuffleArray(state.players.map(p=>p.id), seed);

    const n = shuffled.length;
    const baseSize = (n < 16) ? 2 : 4;
    const {groups, note} = makeGroups(shuffled, baseSize);
    state.groups = groups;
    state._groupingNote = note || "";

    // Assign group indices
    state.groups.forEach((g, gi) => g.forEach(pid => {
      const player = state.players.find(pp => pp.id === pid);
      if(player) player.groupIndex = gi;
    }));

    // Initialize per-group holes (manual default = 1)
    state.groupHoles = {};
    state.groups.forEach((_, gi) => state.groupHoles[String(gi)] = 0);

    state.namesRaw = names.join("\n");
    save();
  }

  function reshuffleGroupsOnly(){
    if(state.players.length === 0) return;
    const ids = state.players.map(p=>p.id);
    const seed = (Date.now() ^ (Math.random()*1e9)) >>> 0;
    const shuffled = shuffleArray(ids, seed);

    const n = shuffled.length;
    const baseSize = (n < 16) ? 2 : 4;
    const {groups, note} = makeGroups(shuffled, baseSize);
    state.groups = groups;
    state._groupingNote = note || "";

    // Reassign group indices
    state.groups.forEach((g, gi) => g.forEach(pid => {
      const player = state.players.find(pp => pp.id === pid);
      if(player) player.groupIndex = gi;
    }));

    // Reset per-group holes to 1 (manual)
    state.groupHoles = {};
    state.groups.forEach((_, gi) => state.groupHoles[String(gi)] = 0);

    save();
  }

  // ---------- scoring helpers ----------
  function totalFor(playerId){
    const arr = state.scores[playerId] || [];
    let sum = 0;
    for(const v of arr){
      if(Number.isFinite(v)) sum += v;
    }
    return sum;
  }

  function holesPlayedFor(playerId){
    const arr = state.scores[playerId] || [];
    return arr.reduce((c,v)=> c + (Number.isFinite(v) ? 1 : 0), 0);
  }

  function getTiesByTotal(){
    const map = new Map(); // total -> [playerId]
    for(const p of state.players){
      const played = holesPlayedFor(p.id);
      if(played === 0) continue;
      const t = totalFor(p.id);
      if(!map.has(t)) map.set(t, []);
      map.get(t).push(p.id);
    }
    const ties = [];
    for(const [tot, ids] of map.entries()){
      if(ids.length > 1) ties.push({total: tot, ids});
    }
    ties.sort((a,b)=> a.total - b.total);
    return ties;
  }

  function comparePlayers(aId, bId){
    const at = totalFor(aId);
    const bt = totalFor(bId);
    if(at !== bt) return at - bt;

    const asd = state.suddenDeath[aId];
    const bsd = state.suddenDeath[bId];
    const aHas = Number.isFinite(asd);
    const bHas = Number.isFinite(bsd);

    if(aHas && bHas && asd !== bsd) return asd - bsd;

    const an = (state.players.find(p=>p.id===aId)?.name || "");
    const bn = (state.players.find(p=>p.id===bId)?.name || "");
    return an.localeCompare(bn);
  }

  // ---------- UI: modal ----------
  function openModal(){ els.modalBack.style.display = "flex"; }
  function closeModal(){
    els.modalBack.style.display = "none";
    els.modalNote.style.display = "none";
    els.modalNote.textContent = "";
  }

  // ---------- UI: roster count ----------
  function renderRosterCount(){
    const names = parseNames(els.namesInput.value);
    els.playerCountPill.textContent = `${names.length} player${names.length===1 ? "" : "s"}`;
  }

  // ---------- UI: progress board ----------
  function groupMaxHolesEntered(groupIndex){
    const g = state.groups[groupIndex] || [];
    let max = 0;
    for(const pid of g){
      max = Math.max(max, holesPlayedFor(pid));
    }
    return max;
  }

  function groupPlayersComplete(groupIndex){
    const g = state.groups[groupIndex] || [];
    let c = 0;
    for(const pid of g){
      if(holesPlayedFor(pid) === 18) c++;
    }
    return c;
  }

  function renderProgressBoard(){
    if(state.groups.length === 0){
      els.progressBoard.style.display = "none";
      return;
    }
    els.progressBoard.style.display = "block";
    els.pbBody.innerHTML = "";

    state.groups.forEach((g, gi) => {
      const currentHole = clampInt(state.groupHoles[String(gi)] ?? 0, 0, 17);
      const maxEntered = groupMaxHolesEntered(gi);
      const completeCount = groupPlayersComplete(gi);
      const playersLabel = g.map(pid => state.players.find(p=>p.id===pid)?.name || "Unknown").join(", ");

      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td><b>G${gi+1}</b></td>
        <td>Hole <b>${currentHole+1}</b></td>
        <td class="r">${maxEntered}/18</td>
        <td class="r">${completeCount}/${g.length}</td>
        <td style="color:var(--muted); font-size:12px;">${escapeHtml(playersLabel)}</td>
      `;
      els.pbBody.appendChild(tr);
    });
  }

  // ---------- UI: groups ----------
  function flashGroupCard(groupEl){
    groupEl.classList.add("flash");
    setTimeout(() => groupEl.classList.remove("flash"), 450);
  }

  function renderGroups(){
    els.groups.innerHTML = "";
    if(state.groups.length === 0){
      els.groups.innerHTML = `<div class="note">No groups yet. Enter names and click <b>Shuffle + Create Groups</b>.</div>`;
      els.groupingNote.style.display = "none";
      return;
    }

    if(state._groupingNote){
      els.groupingNote.style.display = "block";
      els.groupingNote.textContent = state._groupingNote;
    }else{
      els.groupingNote.style.display = "none";
    }

    state.groups.forEach((g, gi) => {
      const groupEl = document.createElement("div");
      groupEl.className = "group";
      groupEl.dataset.gi = String(gi);

      const sizeLabel = g.length === 4 ? "4-player group" : (g.length === 3 ? "3-player group" : "2-player group");

      const head = document.createElement("div");
      head.className = "groupHead";
      head.innerHTML = `
        <div class="gmeta">
          <div class="title">Group ${gi+1} <span class="badge">${sizeLabel}</span></div>
          <div class="sub">Manual hole control • Enter strokes for the group’s current hole</div>
        </div>
        <div class="inline">
          <button class="small ghost" data-action="scorecard">Full scorecard</button>
        </div>
      `;

      const holeCtl = document.createElement("div");
      holeCtl.className = "holeCtl";

      const holeIdx = clampInt(state.groupHoles[String(gi)] ?? 0, 0, 17);

      // Hole dropdown
      const sel = document.createElement("select");
      for(let h=0; h<18; h++){
        const opt = document.createElement("option");
        opt.value = String(h);
        opt.textContent = `Hole ${h+1}`;
        if(h === holeIdx) opt.selected = true;
        sel.appendChild(opt);
      }

      const prev = document.createElement("button");
      prev.className = "small";
      prev.textContent = "◀";

      const next = document.createElement("button");
      next.className = "small";
      next.textContent = "▶";

      const label = document.createElement("div");
      label.className = "holeBig";
      label.textContent = `Entering Hole ${holeIdx+1}`;

      prev.addEventListener("click", () => {
        const cur = clampInt(state.groupHoles[String(gi)] ?? 0, 0, 17);
        const nv = (cur + 17) % 18;
        state.groupHoles[String(gi)] = nv;
        save();
        renderAll();
        flashGroupCard(groupEl);
      });
      next.addEventListener("click", () => {
        const cur = clampInt(state.groupHoles[String(gi)] ?? 0, 0, 17);
        const nv = (cur + 1) % 18;
        state.groupHoles[String(gi)] = nv;
        save();
        renderAll();
        flashGroupCard(groupEl);
      });

      sel.addEventListener("change", () => {
        const nv = clampInt(sel.value, 0, 17);
        state.groupHoles[String(gi)] = nv;
        save();
        renderAll();
        flashGroupCard(groupEl);
      });

      holeCtl.appendChild(label);
      holeCtl.appendChild(prev);
      holeCtl.appendChild(sel);
      holeCtl.appendChild(next);

      const body = document.createElement("div");
      const activeHole = holeIdx;

      for(const pid of g){
        const p = state.players.find(pp => pp.id === pid);
        const row = document.createElement("div");
        row.className = "entryRow";

        const current = state.scores[pid]?.[activeHole];
        const tot = totalFor(pid);

        row.innerHTML = `
          <div class="pname" title="${escapeHtml(p?.name || "")}">${escapeHtml(p?.name || "")}</div>
          <input class="scoreInput" inputmode="numeric" placeholder="Strokes for hole ${activeHole+1}" value="${current ?? ""}" />
          <div class="ptotal">${tot || 0}</div>
        `;

        const input = row.querySelector("input");
        input.addEventListener("input", (e) => {
          const raw = e.target.value.trim();
          if(raw === ""){
            state.scores[pid][activeHole] = null;
          }else{
            const n = Number(raw);
            if(Number.isFinite(n) && n >= 0 && n <= 99){
              state.scores[pid][activeHole] = Math.floor(n);
            }else{
              return;
            }
          }
          save();
          // update local total without full rerender
          row.querySelector(".ptotal").textContent = String(totalFor(pid) || 0);
          renderProgressBoard();
          renderLeaderboard();
        });

        input.addEventListener("keydown", (e) => {
          if(e.key === "Enter"){
            e.preventDefault();
            const inputs = Array.from(groupEl.querySelectorAll("input.scoreInput"));
            const idx = inputs.indexOf(input);
            const next = inputs[idx+1] || null;
            if(next) next.focus();
          }
        });

        body.appendChild(row);
      }

      groupEl.appendChild(head);
      groupEl.appendChild(holeCtl);
      groupEl.appendChild(body);

      head.querySelector('button[data-action="scorecard"]').addEventListener("click", () => openScorecardModal(gi));

      els.groups.appendChild(groupEl);
    });
  }

  // ---------- UI: leaderboard ----------
  function renderLeaderboard(){
    els.lbBody.innerHTML = "";

    if(state.players.length === 0){
      els.lbMeta.textContent = "No players yet";
      return;
    }

    const rows = state.players.map(p => ({
      id: p.id,
      name: p.name,
      group: (p.groupIndex >= 0) ? `Group ${p.groupIndex+1}` : "—",
      holes: holesPlayedFor(p.id),
      total: totalFor(p.id),
      sd: state.suddenDeath[p.id]
    }));

    const ties = getTiesByTotal();
    const tieSet = new Set();
    ties.forEach(t => t.ids.forEach(id => tieSet.add(id)));

    if(state.leaderboardSort === "progress"){
      rows.sort((a,b) => b.holes - a.holes || comparePlayers(a.id,b.id));
    }else{
      rows.sort((a,b) => comparePlayers(a.id,b.id));
    }

    let rank = 1;
    for(let i=0;i<rows.length;i++){
      if(i>0){
        const prev = rows[i-1];
        const cur = rows[i];
        const sameTotal = prev.total === cur.total;
        const prevSD = prev.sd, curSD = cur.sd;
        const bothHaveSD = Number.isFinite(prevSD) && Number.isFinite(curSD);
        const sameSD = bothHaveSD ? (prevSD === curSD) : (!Number.isFinite(prevSD) && !Number.isFinite(curSD));
        if(!(sameTotal && sameSD)){
          rank = i+1;
        }
      }

      const tieStatus = tieSet.has(rows[i].id)
        ? (Number.isFinite(rows[i].sd) ? "Tied (SD entered)" : "Tied (needs SD)")
        : "—";

      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td><b>${rank}</b></td>
        <td><b>${escapeHtml(rows[i].name)}</b></td>
        <td>${escapeHtml(rows[i].group)}</td>
        <td class="r">${rows[i].holes}/18</td>
        <td class="r">${rows[i].total || 0}</td>
        <td>${escapeHtml(tieStatus)}</td>
      `;
      els.lbBody.appendChild(tr);
    }

    const completed = rows.filter(r => r.holes === 18).length;
    els.lbMeta.textContent = `${rows.length} players • ${completed} complete • Sorting: ${state.leaderboardSort === "progress" ? "Holes Played" : "Total (with SD tiebreak)"}`;
  }

  // ---------- UI: sudden death modal ----------
  function openTieModal(){
    const ties = getTiesByTotal();

    els.modalTitle.textContent = "Resolve ties with sudden death";
    els.modalDesc.textContent = "Only players tied on total strokes are shown. Enter sudden-death score (one hole). Lowest wins the tie.";
    els.modalNote.style.display = "none";
    els.modalBody.innerHTML = "";

    if(ties.length === 0){
      els.modalBody.innerHTML = `<div class="note">No ties detected (based on totals entered so far).</div>`;
      els.btnModalPrimary.textContent = "Done";
      els.btnModalPrimary.onclick = () => closeModal();
      openModal();
      return;
    }

    for(const t of ties){
      const block = document.createElement("div");
      block.style.marginBottom = "12px";
      block.innerHTML = `<div class="pill" style="margin-bottom:10px;">Tied total: <b style="color:var(--text); margin-left:6px;">${t.total}</b></div>`;

      for(const pid of t.ids){
        const p = state.players.find(pp=>pp.id===pid);
        const row = document.createElement("div");
        row.className = "sdRow";
        row.innerHTML = `
          <div><b>${escapeHtml(p?.name || "Unknown")}</b> <span class="badge">Total ${t.total}</span></div>
          <input class="scoreInput" inputmode="numeric" placeholder="Sudden death" value="${Number.isFinite(state.suddenDeath[pid]) ? state.suddenDeath[pid] : ""}" />
        `;
        row.querySelector("input").dataset.pid = pid;
        block.appendChild(row);
      }
      els.modalBody.appendChild(block);
    }

    els.btnModalPrimary.textContent = "Apply Sudden Death";
    els.btnModalPrimary.onclick = () => {
      const inputs = Array.from(els.modalBody.querySelectorAll("input.scoreInput"));
      for(const inp of inputs){
        const pid = inp.dataset.pid;
        const raw = inp.value.trim();
        if(!pid) continue;
        if(raw === "") state.suddenDeath[pid] = null;
        else{
          const n = Number(raw);
          if(Number.isFinite(n) && n >= 0 && n <= 99) state.suddenDeath[pid] = Math.floor(n);
        }
      }
      save();
      renderLeaderboard();
      closeModal();
    };
    openModal();
  }

  // ---------- UI: full scorecard modal ----------
  function openScorecardModal(groupIndex){
    const g = state.groups[groupIndex];
    if(!g) return;

    els.modalTitle.textContent = `Group ${groupIndex+1} — Full Scorecard`;
    els.modalDesc.textContent = "Edit any hole. Totals update instantly.";
    els.modalNote.style.display = "none";
    els.modalBody.innerHTML = "";

    const table = document.createElement("div");
    table.style.border = "1px solid rgba(255,255,255,.10)";
    table.style.borderRadius = "14px";
    table.style.overflow = "hidden";
    table.style.background = "rgba(0,0,0,.18)";

    const hdr = document.createElement("div");
    hdr.style.display = "grid";
    hdr.style.gridTemplateColumns = "220px repeat(18, 1fr) 90px";
    hdr.style.borderBottom = "1px solid rgba(255,255,255,.08)";
    hdr.style.background = "rgba(255,255,255,.04)";
    hdr.innerHTML = `<div style="padding:10px;font-weight:900;color:var(--muted);font-size:12px;">Player</div>` +
      Array.from({length:18}, (_,i)=>`<div style="padding:10px;text-align:center;font-weight:900;color:var(--muted);font-size:12px;">${i+1}</div>`).join("") +
      `<div style="padding:10px;text-align:right;font-weight:900;color:var(--muted);font-size:12px;">Total</div>`;
    table.appendChild(hdr);

    for(const pid of g){
      const p = state.players.find(pp=>pp.id===pid);
      const row = document.createElement("div");
      row.style.display = "grid";
      row.style.gridTemplateColumns = "220px repeat(18, 1fr) 90px";
      row.style.borderBottom = "1px solid rgba(255,255,255,.06)";
      row.style.alignItems = "center";

      const nameCell = document.createElement("div");
      nameCell.textContent = p?.name || "Unknown";
      nameCell.style.padding = "10px";
      nameCell.style.fontWeight = "900";
      nameCell.style.whiteSpace = "nowrap";
      nameCell.style.overflow = "hidden";
      nameCell.style.textOverflow = "ellipsis";
      row.appendChild(nameCell);

      let totalCell = null;

      for(let h=0; h<18; h++){
        const cell = document.createElement("div");
        cell.style.padding = "6px";
        const inp = document.createElement("input");
        inp.className = "scoreInput";
        inp.style.padding = "8px 8px";
        inp.style.borderRadius = "10px";
        inp.style.textAlign = "center";
        inp.value = (state.scores[pid][h] ?? "");
        inp.placeholder = "-";
        inp.addEventListener("input", (e)=>{
          const raw = e.target.value.trim();
          if(raw === "") state.scores[pid][h] = null;
          else{
            const n = Number(raw);
            if(Number.isFinite(n) && n >= 0 && n <= 99) state.scores[pid][h] = Math.floor(n);
            else return;
          }
          save();
          if(totalCell) totalCell.textContent = String(totalFor(pid) || 0);
          renderGroups();
          renderProgressBoard();
          renderLeaderboard();
        });
        cell.appendChild(inp);
        row.appendChild(cell);
      }

      totalCell = document.createElement("div");
      totalCell.textContent = String(totalFor(pid) || 0);
      totalCell.style.padding = "10px";
      totalCell.style.textAlign = "right";
      totalCell.style.fontFamily = "var(--mono)";
      totalCell.style.fontWeight = "900";
      row.appendChild(totalCell);

      table.appendChild(row);
    }

    els.modalBody.appendChild(table);
    els.btnModalPrimary.textContent = "Done";
    els.btnModalPrimary.onclick = () => closeModal();
    openModal();
  }

  // ---------- export/import/reset ----------
  function downloadBackupJson(){
    const payload = JSON.stringify(state, null, 2);
    const blob = new Blob([payload], {type:"application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `pftc-tournament-backup-${new Date().toISOString().slice(0,10)}.json`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
    setStatus("Backup downloaded", "ok");
  }

  async function importBackupJson(){
    const input = document.createElement("input");
    input.type = "file";
    input.accept = "application/json";
    input.onchange = async () => {
      const file = input.files?.[0];
      if(!file) return;
      try{
        const text = await file.text();
        const imported = JSON.parse(text);
        if(!confirm("Import this backup? This overwrites your current tournament state.")) return;

        Object.assign(state, imported);

        state.players ||= [];
        state.groups ||= [];
        state.scores ||= {};
        state.suddenDeath ||= {};
        state.leaderboardSort ||= "total";
        state._groupingNote ||= "";
        state.groupHoles ||= {};

        els.namesInput.value = state.namesRaw || state.players.map(p=>p.name).join("\n");
        save();
        renderAll();
        setStatus("Backup imported", "ok");
      }catch(e){
        console.error(e);
        setStatus("Import failed", "bad");
        alert("Import failed. Make sure it’s a valid JSON backup.");
      }
    };
    input.click();
  }

  function resetAll(){
    if(!confirm("Reset everything (names, groups, scores, holes)? This overwrites autosave.")) return;
    localStorage.removeItem(STORAGE_KEY);
    state.namesRaw = "";
    state.players = [];
    state.groups = [];
    state.scores = {};
    state.suddenDeath = {};
    state.groupHoles = {};
    state.leaderboardSort = "total";
    state._groupingNote = "";
    els.namesInput.value = "";
    save();
    renderAll();
    setStatus("Reset", "warn");
  }

  // ---------- render all ----------
  function renderAll(){
    renderRosterCount();
    renderProgressBoard();
    renderGroups();
    renderLeaderboard();
    renderBackupCount();
  }

  function setTab(tab){
    els.tabs.forEach(t => t.classList.toggle("active", t.dataset.tab === tab));
    const scoring = tab === "scoring";
    els.viewScoring.style.display = scoring ? "block" : "none";
    els.viewLeaderboard.style.display = scoring ? "none" : "block";
  }

  // ---------- events ----------
  els.namesInput.addEventListener("input", () => {
    renderRosterCount();
    state.namesRaw = els.namesInput.value;
  });
  els.namesInput.addEventListener("blur", () => {
    state.namesRaw = els.namesInput.value;
    save();
  });

  $("#btnBuild").addEventListener("click", () => {
    const names = parseNames(els.namesInput.value);
    if(names.length < 2){
      setStatus("Need at least 2 players", "warn");
      return;
    }
    buildTournamentFromNames(names);
    renderAll();
    setStatus("Groups created", "ok");
  });

  $("#btnReshuffle").addEventListener("click", () => {
    if(state.players.length < 2){
      setStatus("Nothing to shuffle", "warn");
      return;
    }
    reshuffleGroupsOnly();
    renderAll();
    setStatus("Re-shuffled", "ok");
  });

  $("#btnClearNames").addEventListener("click", () => {
    els.namesInput.value = "";
    state.namesRaw = "";
    renderRosterCount();
    save();
    setStatus("Names cleared", "warn");
  });

  els.tabs.forEach(t => t.addEventListener("click", () => setTab(t.dataset.tab)));

  els.btnSortTotal.addEventListener("click", () => {
    state.leaderboardSort = "total";
    save();
    renderLeaderboard();
    setStatus("Sorted by total", "ok");
  });

  els.btnSortProgress.addEventListener("click", () => {
    state.leaderboardSort = "progress";
    save();
    renderLeaderboard();
    setStatus("Sorted by progress", "ok");
  });

  els.btnShowTies.addEventListener("click", openTieModal);

  // Backups
  els.btnBackupNow.addEventListener("click", () => { save(); backupNow(); });
  els.btnRestoreBackup.addEventListener("click", openBackupsModal);
  els.btnDownloadBackup.addEventListener("click", downloadBackupJson);
  els.btnImport.addEventListener("click", importBackupJson);

  els.btnReset.addEventListener("click", resetAll);

  // Modal close
  els.btnCloseModal.addEventListener("click", closeModal);
  els.modalBack.addEventListener("click", (e) => { if(e.target === els.modalBack) closeModal(); });

  // ---------- init ----------
  const had = load();
  if(had){
    els.namesInput.value = state.namesRaw || state.players.map(p=>p.name).join("\n");
    if (els.saveState) els.saveState.textContent = "on";
    setStatus("Loaded", "ok");
    setTimeout(() => setStatus("Ready", "ready"), 650);
  }else{
    if (els.saveState) els.saveState.textContent = "off";
  }

  renderAll();
  setTab("scoring");
})();
</script>
</body>
</html>
